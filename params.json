{"name":"Jorm","tagline":"jORM is a Lightweight Java ORM","body":"# jORM\r\n\r\njORM is a lightweight Java ORM. It does not aim at solving every database problem. It primarily cures the boilerplatisis that many Java solutions suffer from, while exposing the functionality of the JDBC through a convenient interface.\r\n\r\nAt [Jajja] [1] we've found that many applications have a need both for non teadious mapping of databases and for the full freedom of expression provided by raw SQL. This is an attempt to bridge the gap.\r\n\r\njORM has primarily been tested on Postgres, MySQL and MSSQL. Usage with other engines may lack some of the niftiness provided by the current dialect adoptions.\r\n\r\n\r\n## Getting started\r\n\r\nWould you like to be able to do the following without writing a single line of boilerplate?\r\n\r\n    Goblin goblin = Record.findById(Goblin.class, 42);\r\n    goblin.setName(\"Azog\");\r\n    goblin.save();\r\n    goblin.commit();\r\n    \r\nYou will be done before you are halfway through _getting started_.\r\n\r\n### Getting the code\r\n\r\nGetting jORM to a public maven repo is one of the items on the timeline of the project. For now clone the git repo to get a fresh copy!\r\n\r\n    > git clone git://github.com/jajja/jorm.git\r\n    > cd jorm\r\n    > git checkout 1.0.3\r\n    > mvn install\r\n\r\nThen include the dependency to jORM in any project you are working on that needs a lightweight ORM.\r\n\r\n    <dependency>\r\n        <groupId>com.jajja</groupId>\r\n        <artifactId>jorm</artifactId>\r\n        <version>1.0.3</version>\r\n    </dependency>\r\n\r\nNow that you've got the code, let's see if we cannot conjure some cheap tricks!\r\n\r\n### Configuring database\r\n\r\nThe database abstraction in jORM needs a `javax.sql.DataSource` data source. One recommended implementation is the Tomcat JDBC Connection Pool.\r\n\r\n    DataSource moriaDataSource = new DataSource();\r\n    moriaDataSource.setDriverClassName(\"org.postgresql.Driver\");\r\n    moriaDataSource.setUrl(\"jdbc:postgresql://localhost:5432/moria\");\r\n    moriaDataSource.setUsername(\"gandalf\");\r\n    moriaDataSource.setPassword(\"mellon\");\r\n    \r\n    Database.configure(\"moria\", moriaDataSource);\r\n\r\nThis will configure the pooled data source as a named database. For all of those who prefer Spring Beans this can be achieved through a singleton factory method.\r\n\r\n    <bean id=\"moriaDataSource\" class=\"org.apache.tomcat.jdbc.pool.DataSource\" destroy-method=\"close\">\r\n        <property name=\"driverClassname\" value=\"org.postgresql.Driver\" />\r\n        <property name=\"url\" value=\"jdbc:postgresql://localhost:5432/moria\" />\r\n        <property name=\"username\" value=\"gandalf\" />\r\n        <property name=\"password\" value=\"mellon\" />\r\n    </bean>\r\n\r\n    <bean class=\"com.jajja.jorm.Database\" factory-method=\"get\">\r\n        <property name=\"dataSources\">\r\n            <map>\r\n                <entry key=\"moria\" value-ref=\"moriaDataSource\" />\r\n            </map>\r\n        </property>\r\n    </bean>\r\n\r\n### Using databases\r\n\r\nAll database queries in jORM are executed through a thread local transaction. The first query begins the transaction. After that the transaction can be committed or closed, which implicitly rolls back the transaction.\r\n\r\n    Transaction transaction = Database.open(\"moria\");\r\n    try {\r\n        transaction.select(\"UPDATE goblins SET mindset = 'provoked' RETURNING *\");\r\n        transaction.commit();\r\n    } catch (SQLException e) {\r\n        // handle e\r\n    } finally {\r\n        transaction.close();\r\n    }\r\n\r\nThe database has a shorthand to the thread local transactions. The above can also be expressed as below.\r\n\r\n    try {\r\n        Database.open(\"moria\").select(\"UPDATE goblins SET mindset = 'provoked' RETURNING *\");\r\n        Database.commit(\"moria\");\r\n    } catch (SQLException e) {\r\n        // handle e\r\n    } finally {\r\n        Database.close(\"moria\");\r\n    }\r\n\r\nIf you are using multiple databases it may be a good idea to close all thread local transactions at the end of execution. This can be done by a single call.\r\n\r\n    Database.close();\r\n    \r\nMaybe you were interested in something more than executing generic queries? Let's map a table!\r\n\r\n### Mapping tables\r\n\r\nIn order to map a table we need to get an idea of how it is declared. Imagine a table was created using the following statement.\r\n\r\n    CREATE TABLE goblins (\r\n        id          serial    NOT NULL,\r\n        tribe_id    int       NOT NULL    REFERENCES tribes(id),\r\n        name        varchar   NOT NULL    DEFAULT 'Azog', \r\n        mindset     varchar,\r\n        PRIMARY KEY (id),\r\n        UNIQUE (tribe_id, name)\r\n    );\r\n\r\nTables are mapped by records with a little help by the `@Jorm` annotation. Records bind to the tread local transactions defined by the `database` attribute. The `table` attribute defines the mapped table, and the `id` attribute provides primary key functionality.\r\n\r\n    @Jorm(database=\"moria\", table=\"goblins\", id=\"id\")\r\n    public class Goblin extends Record {  \r\n        public Integer getId() {\r\n            return get(\"id\", Integer.class);\r\n        }\r\n        public void setId(Integer id) {\r\n            set(\"id\", id);\r\n        }\r\n        public Integer getTribeId() {\r\n            return get(\"tribe_id\", Integer.class);\r\n        }\r\n        public void setTribeId(Integer id) {\r\n            set(\"tribe_id\", id);\r\n        }\r\n        public Tribe getTribe() {\r\n            return get(\"tribe_id\", Tribe.class);\r\n        }\r\n        public void setTribe(Tribe tribe) {\r\n            set(\"tribe_id\", tribe);\r\n        }\r\n        public String getName() {\r\n            return get(\"name\", String.class);\r\n        }\r\n        public void setName(String name) {\r\n            set(\"name\", name);\r\n        }\r\n        public String getMindset() {\r\n            return get(\"mindset\", String.class);\r\n        }\r\n        public void setMindset(String mindset) {\r\n            set(\"mindset\", mindset);\r\n        }\r\n    }\r\n\r\nSuch records can be automatically generated by the `Generator` class. Note that the `Goblin#getTribe()` and `Goblin#setTribe()` methods refers to the `tribe_id` field of the mapped `Goblin` record, but `Tribe` record is also cached for subsequent references. Thus simple foreign keys can be mapped, but how would a tribe look?\r\n\r\n    @Jorm(database=\"moria\", table=\"tribes\", id=\"id\")\r\n    public class Tribe extends Record {\r\n        public Integer getId() {\r\n            return get(\"id\", Integer.class);\r\n        }\r\n        public void setId(Integer id) {\r\n            set(\"id\", id);\r\n        }\r\n        public String getName() {\r\n            return get(\"name\", String.class);\r\n        }\r\n        public void setName(String name) {\r\n            set(\"name\", name);\r\n        }\r\n        public List<Goblin> getGoblins() throws SQLException {\r\n            return findReferences(Goblin.class, \"id\");\r\n        }\r\n    }\r\n\r\nThere is no default implementation of `Tribe#setGoblins(List<Goblin>)`. This is not because it is impossible to implement using jORM, but because at this point jORM makes no claim at providing a proper cache for one-to-many relations. There is however a cache implementation for records that could be used for methods like `Tribe#getGoblins()`. For now we'll just let it use a query for each access, and we'll get back to caching strategies.\r\n\r\nDid you notice the `UNIQUE` constraint on goblins? It can be used to provide convenient methods for queries on goblins.\r\n\r\n    public static Goblin findByTribeAndName(Tribe tribe, String name) throws SQLException {\r\n        return find(Goblin.class, new Column(\"tribe_id\", tribe), new Column(\"name\", name));\r\n    }\r\n\r\nIf you prefer the write SQL this can also be achieved through manual queries.\r\n\r\n    public static Goblin findByTribeAndName(Tribe tribe, String name) throws SQLException {\r\n        return Record.select(Goblin.class, \"SELECT * FROM goblins WHERE tribe_id = #1:id# AND name = #2#\", tribe, name);\r\n    }\r\n\r\nThis should be where you've caught the glimpse of a tip of an iceberg, and should ask yourself. What else is there?\r\n\r\n### Immutable fields\r\n\r\nSometimes a field in a record mapped from a table could just as well be immutable, such as `left_at` described in the following SQL create statement. Goblin litter is left at exactly one time, never picked up and never left again.\r\n\r\n    CREATE TABLE litters (\r\n        id          serial    NOT NULL,\r\n        goblin_id   int       NOT NULL    REFERENCES goblins(id),\r\n        stench      float     NOT NULL    CHECK (stench BETWEEN 0 AND 1),\r\n        left_at     timestamp NOT NULL    DEFAULT now(),\r\n        PRIMARY KEY (id)\r\n    );\r\n\r\nMarking immutability for fields can be done by defining the `immutable` attribute in the `@Jorm` mapping. \r\n\r\n    @Jorm(database=\"moria\", table=\"litters\", immutable={\"left_at\"})\r\n    public class Litter extends Record { \r\n        public Integer getId() {\r\n            return get(\"id\", Integer.class);\r\n        }\r\n        public void setId(Integer id) {\r\n            set(\"id\", id);\r\n        }\r\n        public Integer getGoblinId() {\r\n            return get(\"goblin_id\", Integer.class);\r\n        }\r\n        public void setGoblinId(Integer goblinId) {\r\n            set(\"goblin_id\", goblinId);\r\n        }\r\n        public Float getStench() {\r\n            return get(\"stench\", Float.class);\r\n        }\r\n        public void setStench(Float stench) {\r\n            set(\"stench\", stench);\r\n        }\r\n        public java.sql.Timestamp getLeftAt() {\r\n            return get(\"left_at\", java.sql.Timestamp.class);\r\n        }\r\n    }\r\n\r\nThe `left_at` column will never change even if an explicit call to `Record#set(String, Object)` has been made.\r\n\r\n### Rebranded SQL exceptions\r\n\r\nIf you have been wondering why the previous example had a check condition on `stench` in the create statement of `litters`, you are about to find out. The records rebrand `SQLException` through dialect specific adaptions, classifying known errors with specific types.\r\n\r\n    try {\r\n        litter.setStench(2);    // CHECK (stench BETWEEN 0 AND 1),  \r\n        litter.save();\r\n    } catch (CheckViolationException e) {\r\n        // handle exception\r\n    }\r\n\r\nThere are four specific types of exceptions and one generic base exception. If this sounds interesting chek out the section about exception handling.\r\n\r\n### Queries as fields\r\n\r\nSometimes it can be convenient to have the ability to set fields of records to database queries. One of the most frequent queries usable in this context is `now()`, but it can be any valid query resulting in one row and one column. Let's extend `Goblin` with some random functionality!\r\n\r\n    public void relieve() {\r\n        Litter litter = new Litter();\r\n        litter.set(\"stench\", build(\"random() * 0.9\")) ;\r\n        litter.setGoblin(this);\r\n    }\r\n\r\nThe `Record#build(String, Object...)` method provides a query usable as a field value. Note that the goblin instance needs to be saved before the actual value can be accessed!\r\n\r\n\r\n## Queries and SQL markup\r\n\r\nQueries are expressed in a SQL with hash-markup. References to parameters are enclosed by two hashses (#), and use numbers to address parameters in order of appearance.\r\n\r\n    Record.select(\"SELECT * FROM foo WHERE bar < #1# AND #1# < baz AND baz < #2# \", 10, 100);\r\n    \r\nQuaries are implicitly created by `Record#select(String, Object...)`, but can also be explicitly created.\r\n\r\n    Transaction transaction = Database.open(\"bar\");\r\n    Dialect dialect = transaction.getDialect();\r\n    Query query = new Query(dialect, \"SELECT * FROM foo WHERE bar < #1# AND #1# < baz AND baz < #2# \", 10, 100);\r\n    \r\nInstances of `Record` wrap dialect retrieval in `Record#build(String, Object...)`, as a syntactic sugar to build queries shown in the previous section 'Queries as fields'.\r\n\r\n###Tokens\r\n\r\n    #1#     - parameter 1, quoted as value\r\n    #:1#    - parameter 1, quoted as identifier\r\n    #!1#    - parameter 1, not quoted!\r\n\r\n### Escaping\r\n\r\nHashes (#) can be quoted by double-hashing, i.e ##, ? cannot be escaped properly due to design flaws in the JDBC.\r\n\r\n    Record.select(\"SELECT 1 ## 2\");     // = \"SELECT 1 # 2\"\r\n\r\n### Java arrays\r\n\r\n    Integer[] ids = new Integer[]{1, 2, 3};\r\n    Record.select(\"SELECT * FROM foo WHERE id IN (#1#)\", ids);\r\n    Record.select(\"SELECT * FROM foo WHERE id IN (#!1#)\", ids); // No quoting performed!\r\n\r\n### Java collections\r\n\r\n    List<String> names = new LinkedList<String>();\r\n    names.add(\"John\");\r\n    names.add(\"Doe\");\r\n    Record.select(\"SELECT * FROM foo WHERE names IN (#1#)\", names);\r\n\r\n### Java collections\r\n\r\n    List<Record> records = new LinkedList<Record>();\r\n    records.add(someRecord1);\r\n    records.add(someRecord2);\r\n    Record.select(\"SELECT * FROM foo WHERE names IN (#1:some_column#)\", records);\r\n\r\n### Java maps\r\n\r\n    Map<String, Integer> map = new HashMap<String, Integer>();\r\n    map.put(\"foo\", 5);\r\n    map.put(\"bar\", 3);\r\n    Record.select(\"SELECT * FROM foobars WHERE foo_id = #1:foo# OR bar_id = #1:bar#\", map);\r\n\r\n### jORM tables\r\n  \r\n    Record.select(\"SELECT * FROM #1# WHERE id = 5\", table(Goblin.class));   // Modifier ignored, tables are always quoted as a identifiers\r\n\r\n### jORM symbols\r\n\r\n    Record.select(\"SELECT * FROM foo WHERE #1# = 5\", Symbol.get(\"id\")); // Modifier ignored, Symbols are always quoted as identifiers\r\n\r\n### Nested jORM queries\r\n\r\n    Transaction transaction = Database.open(\"moria\");\r\n    Dialect dialect = transaction.getDialect();\r\n    Query subQuery = new Query(dialect, \"SELECT id FROM bar WHERE baz LIKE #1#\", \"%moo%\");\r\n    Query query = new Query(dialect, \"SELECT * FROM foo WHERE bar_id IN (#1#)\", subQuery);\r\n\r\n\r\n## Transaction lifecycle\r\n\r\nTransactions opened to a database are thread local and there is atmost one transaction for each named database (which may be exploited by providing more than one name for a single logical database). These transactions need to be closed at the logical end of execution. A web server may typically reuse threads for subsequent request, making the end of a request the logical end of execution. Any other application  reusing threads need the corresponding adaptions described throughout this section.\r\n\r\n### Transaction access\r\n\r\nThe safest way of ensuring transaction lifecycle through an application reusing threads is to manually close the connection within the scope of the change to the database.\r\n\r\n    Transaction transaction = Database.open(\"moria\");\r\n    try {\r\n        // do stuff \r\n        transaction.commit();\r\n    } catch (SQLException e) {\r\n        // handle exception\r\n    } finally {\r\n        transaction.close();\r\n    }\r\n\r\nHowever, code modularization can make passing of references to transactions cumbersome. For this reason transactions can be uniquely accessed through the named database, in the context of the current thread.\r\n\r\n    Database.open(\"moria\");\r\n    try {\r\n        // do stuff\r\n        Database.commit(\"moria\");\r\n    } catch (SQLException e) {\r\n        // handle exception\r\n    } finally {\r\n        Database.close(\"moria\");\r\n    }\r\n\r\nThere is conveniently wrapped by static methods of the record, using `@Jorm` annotations to define named datbases.\r\n\r\n    Record.open(Goblin.class);\r\n    try {\r\n        // do stuff\r\n        Record.commit(Goblin.class);\r\n    } catch (SQLException e) {\r\n        // handle exception\r\n    } finally {\r\n        Record.close(Goblin.class);\r\n    }\r\n\r\nTransactions are even available through record instances, which can sometimes be convenient. Note that any record may act as reference to the thread local transaction possibly shared by multiple records.\r\n\r\n    Record context = null\r\n    try {\r\n        // do stuff\r\n        if (context != null) context.commit();\r\n    } catch (SQLException e) {\r\n        // handle exception\r\n    } finally {\r\n        if (context != null) context.close();\r\n        // else what?\r\n    }\r\n\r\nThis last example points to the fact that execution is not always predictable. In most applications a runtime exception may occurr depending on user input or other uncontrolled circumstances.\r\n\r\n    try {\r\n        // do unpredictable stuff\r\n    } finally {\r\n        Database.close();\r\n        // release thread\r\n    }\r\n\r\nThe above example closes all thread local transactions are releasing the current thread to its imagined thread pool. It may be considered good practice to build this into your applications execution lifecycle.\r\n\r\n### Transaction savepoints\r\n\r\nFor some types of problems it may be beneficial to make use of savepoints. For this reason the savepoints of JDBC are wrapped by transactions.\r\n\r\n    Transation transaction = Database.open(\"moria\");\r\n    try {\r\n        Goblin azog = new Goblin(\"Azog\");\r\n        Tribe tribe = Record.findById(Tribe.class, 1);\r\n        azog.setTribe(tribe);\r\n        Savepoint savepoint = transaction.save();\r\n        try {\r\n            azog.save();\r\n            transaction.release(savepoint);\r\n        } catch (UniqueViolationException) {\r\n            transaction.rollback(savepoint);\r\n            azog = findByTribeAndName(tribe, \"Azog\");\r\n        }\r\n        // do more stuff\r\n        transaction.commit();\r\n    } catch (SQLException e) {\r\n        // handle exception\r\n    } finally {\r\n        transaction.close();\r\n    }\r\n\r\nNote that not every database engine supports release of savepoints. MSSQL only supports rollback, and there is more to read about engine/driver specific behaviour in the next section!\r\n\r\n## Database engines\r\n\r\njORM has been tested on Postgres, MySQL and MSSQL. If you have a license to a database engine and would like to contribute, please feel free to contact the authors.\r\n\r\n### Is jORM database agnostic?\r\n\r\nThe not so simple answer is _yes and no_! The library should be able to execute database agnostically using the JDBC as abstraction. However, jORM takes advantage of engine specific functionality. For instance Postgres is the only database engine supporting the `RETURNING` clause (that we've stumbled across so far), and thus Postgres integrations using jORM do not need to query for results explicitly after an insert or update. \r\n\r\nThere are also targeted fixes patching unexpected behaviour in specific JDBC-implementations. Any database engines that have not been validated might just as well contain similar problems in their respecitve implementations of the JDBC.\r\n\r\nOne thing that will differ if using another database egine is a rebrand strategy for `SQLException` that jORM use to classify different types of SQL errors. These are only available for Postgres, MySQL and MSSQL at this moment. More about this will appear in the nondistant future.\r\n\r\n\r\n## To be continued..\r\n\r\nThis README will be updated with more advanced and in-depth examples of how to best make use of jORM. One of the first things on our TODO list is to document the SQL markup syntax for queries through records and transactions properly.\r\n\r\n[1]: http://www.jajja.com \"Jajja Communications AB\"\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}